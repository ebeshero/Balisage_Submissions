<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-5.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="balisage-1-5.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0-subset Balisage-1.5">

    <title>Adventures in Correcting XML Collation Problems with Python and XSLT</title>
    <subtitle>Untangling the <emphasis role="ital">Frankenstein Variorum</emphasis></subtitle>
    <info>
        <abstract>
            <para>The process of instructing a computer to compare texts, known as computer-aided collation, might resemble trying to fix a power loom when the threads it is supposed to weave together become tangled. The power of the automated weaving continues, with the threads improperly aligned and the pattern broken in a way that can make it difficult to isolate the cause of the problem. Automating a tedious process magnifies the complexity of error-correction, sometimes calling for new tooling to help us perfect the weaving or collating process.</para>
            <para>The authors are attempting to refine a collation algorithm to improve its alignment of variant passages in the <link xlink:href="https://frankensteinvariorum.github.io/">Frankenstein Variorum</link> project. We have begun with a Python script that tokenizes and normalizes the texts of the editions and delivers them to <link xlink:href="https://collatex.net/">collateX</link> for processing the collation and delivering TEI-conformant output for our project. In post-processing stages after running the collation, we apply a series of XSLT transformations to the collation output. This post-collation XSLT pipeline publishes the digital variorum edition, which prepares each output witness in TEI XML to store information about its own variance from the other editions. We have discussed that pipeline elsewhere, but our interest in this paper is in efforts to repair and correct and improve the collation process.</para>
            <para>We have applied Schematron and XSLT in post-processing to correct patterns of erroneous alignments, but eventually realized that the problems we were trying to solve required repairing the collation algorithm. We are now experimenting with revising the collation algorithm in two ways: 1) by fine-tuning the text preparation algorithms we apply in our Python file that delivers text to the collateX software, and 2) by attempting to introduce those same text preparation algorithms entirely with XSLT using the Text Alignment Network's XSLT application of <code>tan:diff()</code> and <code>tan:collate()</code>, introduced by Joel Kalvesmaki at the 2021 Balisage conference. In this paper we discuss the challenges of figuring out where and how to intervene in the collation process, and what we are learning about how far we can take XSLT and Schematron in helping to automate the preparation, collation, and correction process.</para>
        </abstract>
        <author>
            <personname>
                <firstname>Elisa</firstname>
                <othername>E.</othername>
                <surname>Beshero-Bondar</surname>
            </personname>
            <personblurb>
                <para>Elisa Beshero-Bondar explores and teaches document data modeling with the XML
                    family of languages. She serves on the TEI Technical Council and is the founder
                    and organizer of the <link xlink:href="https://digitalmitford.org"
                        xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Digital
                        Mitford project</link> and <link
                        xlink:href="https://digitalmitford.github.io/DigMitCS/" xlink:type="simple"
                        xlink:show="new" xlink:actuate="onRequest">its usually annual coding
                        school</link>. She experiments with visualizing data from complex document
                    structures like epic poems and with computer-assisted collation of differently
                    encoded editions of <link xlink:href="https://frankensteinvariorum.github.io/"
                        xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"><emphasis
                            role="ital">Frankenstein</emphasis></link>. Her ongoing adventures with
                    markup technologies are documented on <link xlink:href="https://newtfire.org"
                        xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">her
                        development site at newtfire.org</link>.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Professor of Digital Humanities</jobtitle>
                <jobtitle>Program Chair of Digital Media, Arts, and Technology</jobtitle>
                <orgname>Penn State Erie, The Behrend College</orgname>
            </affiliation>
            <email>eeb4@psu.edu</email>
        </author>
        <keywordset role="author">
            <keyword>collation</keyword>
            <keyword>tokenization</keyword>
            <keyword>normalization</keyword>
            <keyword>alignment</keyword>
            <keyword>Gothenburg model</keyword>
            <keyword>Python</keyword>
            <keyword>XSLT</keyword>
            <keyword>stand-off markup</keyword>
            <keyword>stand-off pointers</keyword>
        </keywordset>
    </info>
    <section>
        <title>Cycles of time in the Gothenburg model for computer-aided collation</title>
        <para>A project applying computer-aided collation, by which we mean the guidance of a computational system to compare texts, challenges our debugging capacities in ways that scale and consume far more time than humans may expect at the outset. Scholarly editors working on collation projects often do so in the context of preparing critical editions that present a text-bearing cultural object in all its variations. These editors tend to prioritize a high degree of accuracy in the marking of variants, and may come to a computer-aided collation project prepared for saintly patience and endurance to spot and correct each and every error. Yet endurance has its mortal limits, and computationally-generated errors require the developers' patient scrutiny to be directed not to the outputs but to the preparation of the inputs. Humanities scholars (the author included) may be tempted to hand-correct errors as they spot them to perfect an output for a swift project launch, but this is brittle and can even compound errors, even if applied by a computer script that finds and replaces every instance of a distinctive pattern in the output. We should limit correcting the output, even computationally, in favor of making changes at the guidance and preparation stages and re-running the collation software. Taking cycles of time to study the errors generated by a collation process should lead us to a state of enlightenment about precisely what we are comparing and precisely how it is to be compared. Do we consider computer collation a form of machine learning, in which we expend energy preparing the training set? But it is really the scholars who learn over cycles of collation re-processing, with enhanced awareness of their systems for comparison. Perhaps we should think of computer-aided collation as machine-assisted human learning.</para>
        <para>This paper marks a return to work on a digital collation project that began in the years just before the pandemic, and paused a moment in 2020-2021 when several of the original project members moved to new jobs and I, as the one leading the preparation of the collation data, concentrated on teaching and running a program in a new university during a time of global pandemic crisis disrupting university work. Returning to work on the <emphasis role="ital">Frankenstein Variorum</emphasis> has necessitated reorienting myself to complicated processes and reviewing the problems we identified as we last documented and left them. This has been a labor of reviewing and sampling our past code, updating its documentation, and trying to find new and better ways to continue our work. We set out to prepare a comparison of five distinct versions of the novel <emphasis role="ital">Frankenstein</emphasis>, without taking any single edition as the default standard. Rather, we seek to provide readers a reading view for each of the five versions that demonstrates which passages were altered and how heavily they were altered. The <emphasis role="ital">Frankenstein Variorum</emphasis> should help readers to see a heavily revised text and understand the abandoned, discontinuous branches of that revision.</para>
        <para>Much of this project has investigated methods for moving between hierarchical and <quote>flat</quote> text structures, moving back and forth between markup and strings as we thread our texts into the machine power-loom of collation software, examine the woven output, and contemplate how to untangle the snags and snarls we find in the <quote>woven textile</quote> of collation output. The Gothenburg model guides our work, an elaboration of five distinct stages of work necessary to guide machine-assisted collation as established in 2009 by the developers of collateX and Juxta in Gothenburg, Sweden: 
            
            <orderedlist>
                <listitem>
                    <para>Tokenization (deciding on the smallest units of comparison)</para>
                </listitem>
                <listitem>
                    <para>Normalization/Regularization (deciding what distinct features in the source documents need to be suppressed from comparison. An easy example of a normlization step is indicating that ampersands are stand in for the word <quote>and</quote>. A more difficult judgment call is the handling of notational metamarks or even editorial markup that assist reading in one document, but should be skipped over by the collation software as not meaningful for comparison with other documents.)</para>
                </listitem>
                <listitem>
                    <para>Alignment (locating via software parallel equivalent passages and their moments of unison and divergence)</para>
                </listitem>
                <listitem>
                    <para>Analysis/Feedback (reviewing, correcting, adjusting the alignment algorithm as well as normalization/regularization method</para>
                </listitem>
                <listitem>
                    <para>Visualization (finding an effective way to show and share the collation results)<footnote>
                        <para>Interedition Development Group, <quote>The Gothenburg Model</quote>, 2010-2019. <link xlink:href="https://collatex.net/doc/">https://collatex.net/doc/</link>. For more on the summit and workshop of collation software developers in 2009 that formulated the Gothenburg model, see Ronald Haentjens Dekker, Dirk van Hulle, Gregor Middell, Vincent Neyt, and Joris van Zundert. <quote>Computer-supported collation of modern manuscripts: CollateX and the Beckett Digital Manuscript Project.</quote> In <emphasis role="ital">Digital Scholarship in the Humanities</emphasis> 30:3 (December 2014) pp. 3-4.</para>
                    </footnote></para>
                </listitem>
            </orderedlist>
        </para>
        <para>These stages are usually numbered, but that numbering belies the cyclicality of the Gothenburg process. We scholars who collate have to try and try again to retool, rethink, re-run, and even this is not a steady process because we have to decide whether certain kinds of problems are best resolved by changing the <quote>pre-processing</quote> to improve the normalization prior to collation, or to apply corrections to collation output errors in <quote>post-processing</quote>. Collation projects of significant length and complexity require computational assistance to visualize not only the collation output but crucially to locate patterns in the collation errors. The Analysis/Feedback stage is critical and without giving it procedural care, we risk inaccuracies or the human error introduced during hand-correcting outputs.</para>
       <para>In returning to work on the <emphasis role="ital">Frankenstein Variorum</emphasis>, I have concentrated on the Analysis/Feedback stage to try to find patterns in the snags of our collation weave, and to try different normalization and alignment methods to improve the work. The work requires close observation of meticulous details (plenty of myopic eye fatigue), but also a return to the long view of our research goals. As David J. Birnbaum and Elena Spadini have discussed, normalization is interpretive, reflecting on transcription decisions and deciding on what properties should and should not be considered worthy of comparison.<footnote>
                <para>Birnbaum, David J. and Elena Spadini, <quote>Reassessing the locus of normalization in machine-assisted collation</quote> <emphasis role="ital">DHQ: Digital Humanities Quarterly</emphasis> 14:3 (2020). <link xlink:href="http://www.digitalhumanities.org/dhq/vol/14/3/000489/000489.html">http://www.digitalhumanities.org/dhq/vol/14/3/000489/000489.html</link>.</para>
            </footnote> In our project, the great challenge for the normalization process has been contending with the diplomatic markup of the Shelley-Godwin Archive's manuscript notebook edition of <emphasis role="ital">Frankenstein</emphasis>. The meticulous page-by-page markup structured on page surfaces and zones cannot be compared with the semantic trees representing the other print-based editions in the project, though deletions do matter, as do the insertion points of marginal additions and corrections. Alignment of our variant passages is improved by revisiting our normalization algorithms, and also by testing our software tools as soon as we recognize problems.</para>
   <para>In this paper, I venture that the software we choose to assist us with aligning collations matters not only for its effectiveness in applying an algorithm like Needleman Wunsch or Dekker or TAN Diff, but also for its capacity to guide the scholar in the documentation of a highly complex, time-consuming, cyclical process. In the following sections I first unfold the elaborate pipeline process of our collation and visualization, to then introduce problems we have found and efforts to resolve them by exploring a new method of alignment. XSLT has been vital to the pre-processing and post-processing of our edition and collation data, but now we find it may be a benefit for handling the entire process of tree flattening, string collation, and edition construction. Long ago in the early years of XSLT, John Bradley extolled its virtues not only for publishing documents but also for text scholarly analysis and research.<footnote><para>John Bradley, <quote>Text Tools</quote> in <emphasis role="ital">A Companion to Digital Humanities</emphasis>, ed. Susan Schreibman, Ray Siemens, and John Unsworth (Wiley, 2004) pages 505-522.</para></footnote> Though it is common in the Digital Humanities community now to think of Python or R Studio as the only necessary tools one needs for text analysis, the strengths of XSLT seem realized in its precision and elegance in transforming structured and unstructured text and its particular ease of documentation for the humanities researcher. In this paper, I contemplate a move from applying normalizing algorithms to <quote>stringified XML</quote> in Python to restating and revising those algorithms in XSLT.</para>
    </section>
    <section>
        <title>The <emphasis role="ital">Frankenstein Variorum</emphasis> project and its production pipeline</title>
        <para>The <emphasis role="ital">Frankenstein Variorum</emphasis> project (hereafter referred to as <emphasis role="ital">FV</emphasis>) is an ongoing collation project that began during the recent 1818-2018 bicentennial celebrating the first publication of Mary Shelley's novel. We are constructing a digital variorum edition that highlights alterations to the novel <emphasis role="ital">Frankenstein</emphasis> over five key moments from its first drafting in 1816 to its author’s final revisions by 1831. If we think of each source edition for the collation as a <quote>thread</quote>, the collation algorithm can be said to weave five threads together into a woven pattern that helps us to identify the moments when the editions align together and where they diverge. The project applies automated collation, so far working with the software collateX to create a <quote>weave</quote> of five editions of the novel, output in TEI-conformant XML. We have shared papers at <emphasis role="ital">Balisage</emphasis> in previous years about our processing work, preparing differently-encoded source editions for machine-assisted collation,
         <footnote>
             <para>Beshero-Bondar, Elisa Eileen. <quote>Rebuilding a Digital Frankenstein by 2018: Reflections toward a Theory of Losses and Gains in Up-Translation.</quote> Presented at Up-Translation and Up-Transformation: Tasks, Challenges, and Solutions, Washington, DC, July 31, 2017. In <emphasis role="ital">Proceedings of Up-Translation and Up-Transformation: Tasks, Challenges, and Solutions. Balisage Series on Markup Technologies</emphasis>, vol. 20 (2017). <link xlink:href="https://doi.org/10.4242/BalisageVol20.Beshero-Bondar01.">https://doi.org/10.4242/BalisageVol20.Beshero-Bondar01</link>.</para>
        </footnote> and working with the output of collation to construct a <quote>spine</quote> file in TEI critical apparatus form, which coordinates the preparation of the edition files that hold elements locating moments of divergence from the other editions.<footnote>
            <para>See Beshero-Bondar, Elisa E., and Raffaele Viglianti. <quote>Stand-off Bridges in the <emphasis role="ital">Frankenstein Variorum</emphasis> Project: Interchange and Interoperability within TEI Markup Ecosystems.</quote> Presented at Balisage: The Markup Conference 2018, Washington, DC, July 31 - August 3, 2018. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference 2018. Balisage Series on Markup Technologies</emphasis>, vol. 21 (2018); <link xlink:href="https://doi.org/10.4242/BalisageVol21.Beshero-Bondar01.">https://doi.org/10.4242/BalisageVol21.Beshero-Bondar01</link>. I am also grateful to Michael Sperberg-McQueen and David Birnbaum for their guidance of my efforts to <quote>raise</quote> flattened markup into hierarchical markup leading to a Balisage paper evaluating multiple methods for attempting this. See Birnbaum, David J., Elisa E. Beshero-Bondar and C. M. Sperberg-McQueen. <quote>Flattening and unflattening XML markup: a Zen garden of XSLT and other tools.</quote> Presented at Balisage: The Markup Conference 2018, Washington, DC, July 31 - August 3, 2018. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference 2018. Balisage Series on Markup Technologies</emphasis>, vol. 21 (2018). <link xlink:href="https://doi.org/10.4242/BalisageVol21.Birnbaum01">https://doi.org/10.4242/BalisageVol21.Birnbaum01</link>. 
</para>
        </footnote></para>
        <para>Our source <quote>threads</quote> for weaving the collation pattern include two well-known digital editions: <link xlink:href="http://knarf.english.upenn.edu/">The Pennsylvania Electronic Edition (PAEE)</link>, an early hypertext edition produced at the University of Pennsylvania in the mid 1990s by Stuart Curran and Jack Lynch that represents the 1818 and 1831 published editions of the novel, and the <link xlink:href="http://shelleygodwinarchive.org/contents/frankenstein/">Shelley-Godwin Archive's edition of the manuscript notebooks (S-GA)</link> published in 2013 by the University of Maryland. We prepared two other editions in XML representing William Godwin’s corrections of his daughter's edition from 1823, and the <quote>Thomas copy</quote>, which represents Mary Shelley’s corrections and proposed revisions written in a copy of the 1818 edition left in Italy with her friend Mrs. Thomas.</para>
        <para>Here is a summary of our project’s production pipeline, discussed in more detail in previous Balisage papers:
            <orderedlist>
                <listitem>
                    <para>Preparing differently-encoded XML files for collation. This involves several stages of document analysis and pre-processing:
                    <itemizedlist>
                        <listitem>
                            <para>Identifying markup that indicates structures we care about: letter, chapter, paragraphs, and verse structures, for example. Where these change from version to version, we want to be able to track them by including this markup with the text of each edition in the collation.</para>
                        </listitem>
                        <listitem>
                            <para>Re-sequencing margin annotations coded in the SGA edition of the manuscript notebook, as these margin annotations were encoded at the ends of each XML file and needed to be moved into reading order for collation. (For this resequencing, we wrote XSLT to follow the <code>@xml:id</code>s and pointers on each SGA edition file).</para>
                        </listitem>
                        <listitem>
                            <para>Determining and marking <quote>chunk</quote> boundaries (dividing the texts into units that mostly start and end the same way to facilitate comparison): We divided <emphasis role="ital">Frankenstein</emphasis> into 33 <quote>chunks</quote> roughly corresponding with chapter structures. (Later in refining the collation we subdivided some of these chunks (breaking some complicated chunks into 3 -5 <quote>sub-chunks</quote>) for a more granular comparison of shorter passages.)</para>
                        </listitem>
                        <listitem>
                            <para><quote>Flattening</quote> the edition files' structural markup into Trojan milestone elements (converting structural elements that wrap chapters, letters, and paragraphs like <code>&lt;div xml:id="chap-ID"&gt;</code> into self-closed matched pairs of elements to mark the starts and ends of structures: <code>div sID="chap-ID"/></code> and <code>div eID="chap-ID"/></code>). The use of these empty milestones facililates the inclusion of markup in the collation when, for example, a version inserts a new paragraph of chapter boundary within an otherwise identical passage in the other editions. Ultimately this flattening in pre-processing facilitates post-processing of the edition files from text strings to XML holding collation data.
                            <footnote>
                                <para>On Trojan markup, see Steven J. DeRose and David G. Durand, <quote>The TEI Hypertext Guidelines</quote>, <emphasis role="ital">Computers and the Humanities</emphasis> vol. 29 (1995), pp. 181-190. <link xlink:href="https://link.springer.com/content/pdf/10.1007/BF01830615.pdf">https://link.springer.com/content/pdf/10.1007/BF01830615.pdf</link>.
                                    and Sperberg-McQueen, C. M. <quote>Representing concurrent document structures using Trojan Horse markup.</quote> Presented at Balisage: The Markup Conference 2018, Washington, DC, July 31 - August 3, 2018. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference 2018. Balisage Series on Markup Technologies</emphasis>, vol. 21 (2018). <link xlink:href="https://doi.org/10.4242/BalisageVol21.Sperberg-McQueen01">https://doi.org/10.4242/BalisageVol21.Sperberg-McQueen01</link>.</para>
                            </footnote>
                            </para>
                        </listitem>
                    </itemizedlist>
                    </para>
                </listitem>
                <listitem><para>Normalizing the text and processing the collation. Up to this point, we have been applying a Python script to read the flattened XML as text, and to introduce a series of about 25 normalizations via regular expression patterns that instruct collateX to (among other things):
                <itemizedlist>
                    <listitem>
                        <para>Convert <quote>&amp;</quote> into <quote>and</quote></para>
                    </listitem>
                    <listitem>
                        <para>Ignore some angle-bracketed material that is not relevant to the collation: For example, convert <code>&lt;surface.+?/&gt;</code> and <code>&lt;zone.+?/&gt;</code> into <code>""</code> (nothing) when comparing strings of the editions</para>
                    </listitem>
                    <listitem>
                        <para>Simplify to ignore the attribute values on Trojan milestone elements. For example, remove the <code>@sID</code> and <code>@eID</code> attributes by converting <code>(&lt;p)\s+.+?(/&gt;)</code> into <code>$1$2</code> (or simply <code>&lt;p/&gt;</code>) so that all paragraph markers are read as the same.</para>
                    </listitem>
                </itemizedlist>
                    
                </para></listitem>
                <listitem><para>Work with the output of the collation to prepare, in a series of stages, a very important file that we call our <quote>spine</quote>, which contains the collation data that organizes the variorum edition project. The format of the output is a prototype of a TEI critical apparatus, and in preliminary stages it is not quite valid against the TEI. Here is an example of a part of the <quote>spine</quote> in an early post-processing stage, featuring a passage in which Victor Frankenstein beholds his completed Creature in each of the five editions. Notice that the <code>&lt;rdg&gt;</code> elements contain mixed content: each is holding a passage from the source edition that is crucially <emphasis role="ital">not normalized</emphasis>. This is our project’s particular approach to the <emphasis role="ital">parallel segmentation</emphasis> method of preparing a critical apparatus in TEI P5. Eventually the <quote>spine</quote> of the collation needs to contain data particular to each version in order to reconstruct that version so that it stores information about its variations from the other versions. In the not-quite-TEI stage of our post-collation process represented here, we can see that a use of the Trojan milestone markers to indicate the starting points of paragraphs, and their values indicate their location in the original source edition's XML hierarchy.<footnote><para>On the parallel segmentation method for handling a critical apparatus in TEI P5 see the TEI Guidelines: TEI Consortium, eds. <quote>4.3.2 Floating Texts.</quote> <emphasis role="ital">TEI P5: Guidelines for Electronic Text Encoding and Interchange</emphasis>. 4.4.0. April 19, 2022. TEI Consortium. http://www.tei-c.org/release/doc/tei-p5-doc/en/html/DS.html#DSFLT (2022-07-19).</para></footnote>
                    
                    <programlisting language="xml">   
    &lt;cx:apparatus xmlns:cx="http://interedition.eu/collatex/ns/1.0"&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['chapter']"&gt;
			      &lt;rdg wit="f1818"&gt;&lt;milestone n="4" type="start" unit="chapter"/&gt;
			         &lt;head sID="novel1_letter4_chapter4_div4_div4_head1"/&gt;CHAPTER &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;&lt;milestone n="4" type="start" unit="chapter"/&gt;
			         &lt;head sID="novel1_letter4_chapter4_div4_div4_head1"/&gt;CHAPTER &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;&lt;milestone n="4" type="start" unit="chapter"/&gt;
			         &lt;head sID="novel1_letter4_chapter4_div4_div4_head1"/&gt;CHAPTER &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;&lt;milestone n="5" type="start" unit="chapter"/&gt;
			         &lt;head sID="novel1_letter4_chapter5_div4_div5_head1"/&gt;CHAPTER &lt;/rdg&gt;
			      &lt;rdg wit="fMS"&gt;&lt;lb n="c56-0045__main__1"/&gt;
			         &lt;milestone spanTo="#c56-0045.04" unit="tei:head"/&gt;Chapter &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['7&lt;shi rend=&#34;sup&#34;&gt;&lt;/shi&gt;&lt;p/&gt;']"&gt;
			      &lt;rdg wit="fMS"&gt;7&lt;shi rend="sup"&gt;&lt;/shi&gt;
			         &lt;milestone unit="tei:p"/&gt;&lt;lb n="c56-0045__main__2"/&gt; &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
		    &lt;rdgGrp n="['iv.&lt;p/&gt;']"&gt;
			      &lt;rdg wit="f1818"&gt;IV.&lt;head eID="novel1_letter4_chapter4_div4_div4_head1"/&gt;
			         &lt;p sID="novel1_letter4_chapter4_div4_div4_p1"/&gt;&lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;IV.&lt;head eID="novel1_letter4_chapter4_div4_div4_head1"/&gt;
			         &lt;p sID="novel1_letter4_chapter4_div4_div4_p1"/&gt;&lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;IV.&lt;head eID="novel1_letter4_chapter4_div4_div4_head1"/&gt;
			         &lt;p sID="novel1_letter4_chapter4_div4_div4_p1"/&gt;&lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
		    &lt;rdgGrp n="['v.&lt;p/&gt;']"&gt;
			      &lt;rdg wit="f1831"&gt;V.&lt;head eID="novel1_letter4_chapter5_div4_div5_head1"/&gt;
			         &lt;p sID="novel1_letter4_chapter5_div4_div5_p1"/&gt; &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['it']"&gt;
			      &lt;rdg wit="f1818"&gt;I&lt;hi sID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt;T
			         &lt;hi eID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt; &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;I&lt;hi sID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt;T
			         &lt;hi eID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt; &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;I&lt;hi sID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt;T
			         &lt;hi eID="novel1_letter4_chapter4_div4_div4_p1_hi1"/&gt; &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;I&lt;hi sID="novel1_letter4_chapter5_div4_div5_p1_hi1"/&gt;T
			         &lt;hi eID="novel1_letter4_chapter5_div4_div5_p1_hi1"/&gt; &lt;/rdg&gt;
			      &lt;rdg wit="fMS"&gt;It &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['was', 'on', 'a', 'dreary', 'night', 'of']"&gt;
			      &lt;rdg wit="f1818"&gt;was on a dreary night of &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;was on a dreary night of &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;was on a dreary night of &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;was on a dreary night of &lt;/rdg&gt;
			      &lt;rdg wit="fMS"&gt;was on a dreary night of &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['november', '']"&gt;
			      &lt;rdg wit="fMS"&gt;November &lt;lb n="c56-0045__main__3"/&gt; &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
		    &lt;rdgGrp n="['november,']"&gt;
			      &lt;rdg wit="f1818"&gt;November, &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;November, &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;November, &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;November, &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['that', 'i', 'beheld']"&gt;
			      &lt;rdg wit="f1818"&gt;that I beheld &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;that I beheld &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;that I beheld &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;that I beheld &lt;/rdg&gt;
			      &lt;rdg wit="fMS"&gt;that I beheld &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
	  &lt;app&gt;
		    &lt;rdgGrp n="['&lt;del&gt;the', 'frame', 'on', 'whic&lt;del&gt;',
		    'my', 'man', 'completeed,.', '&lt;del&gt;and&lt;del&gt;']"&gt;
			      &lt;rdg wit="fMS"&gt;&lt;del rend="strikethrough" sID="c56-0045__main__d2e9718"/&gt;
			         the frame on whic&lt;del eID="c56-0045__main__d2e9718"/&gt; my man 
			         comple&lt;mdel&gt;at&lt;/mdel&gt;teed,. 
			         &lt;del rend="strikethrough" sID="c56-0045__main__d2e9739"/&gt;
			         And&lt;del eID="c56-0045__main__d2e9739"/&gt;&lt;lb n="c56-0045__main__4"/&gt; &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
		    &lt;rdgGrp n="['the', 'accomplishment', 'of']"&gt;
			      &lt;rdg wit="f1818"&gt;the accomplishment of my toils. &lt;/rdg&gt;
			      &lt;rdg wit="f1823"&gt;the accomplishment of my toils. &lt;/rdg&gt;
			      &lt;rdg wit="fThomas"&gt;the accomplishment of my toils. &lt;/rdg&gt;
			      &lt;rdg wit="f1831"&gt;the accomplishment of my toils. &lt;/rdg&gt;
		    &lt;/rdgGrp&gt;
	  &lt;/app&gt;
                    </programlisting>
    
   Apply this collation data in post-processing to prepare the edition files:
                    <itemizedlist>
                        <listitem>
                            <para><quote>Raise</quote> the flattened editions in their original form (convert Trojan milestones into the original tree hierarchy).</para>
                        </listitem>
                        <listitem>
                            <para>With XSLT, pull from the <quote>spine</quote> file to map <code>&lt;seg&gt;</code> elements to each separate edition file at every point of variance captured in the collation. Each <code>&lt;seg&gt;</code> element is keyed by XPath location markers to the collation <quote>spine</quote> file. Here is an example of <code>&lt;seg&gt;</code> elements applied in the 1818 edition. The <code>@xml:id</code> are keyed to the specific <code>&lt;app&gt;</code> elements in the portion of the spine representing collation unit 10. Where the collation <quote>spine</quote> marks passages around chapter headings and paragraph boundaries, we apply a <code>@part</code> attribute to designate an initial and final portion within the structure of the edition XML file:
                            <programlisting language="xml">
         &lt;div type="collation"&gt;
            &lt;milestone n="4" type="start" unit="chapter"/&gt;
            &lt;head xml:id="novel1_letter4_chapter4_div4_div4_head1"&gt;
                CHAPTER &lt;seg part="I" xml:id="C10_app2-f1818__I"&gt;IV.&lt;/seg&gt;
            &lt;/head&gt;
            &lt;p xml:id="novel1_letter4_chapter4_div4_div4_p1"&gt;
               &lt;seg part="F" xml:id="C10_app2-f1818__F"&gt;
               &lt;/seg&gt;I&lt;hi xml:id="novel1_letter4_chapter4_div4_div4_p1_hi1"&gt;T&lt;/hi&gt;
                  was on a dreary night of &lt;seg xml:id="C10_app5-f1818"&gt;November, &lt;/seg&gt;
                  that I beheld &lt;seg xml:id="C10_app7-f1818"&gt;the accomplishment of my toils. &lt;/seg&gt;
                  With an anxiety that almost amounted to &lt;seg xml:id="C10_app9-f1818"&gt;agony, &lt;/seg&gt;
                  I collected &lt;seg xml:id="C10_app11-f1818"&gt;the &lt;/seg&gt;instruments of life around 
                  &lt;seg xml:id="C10_app14-f1818"&gt;me, that &lt;/seg&gt;I 
                  &lt;seg xml:id="C10_app16-f1818"&gt;might infuse &lt;/seg&gt;a spark of being 
                  into the lifeless thing that lay at my feet. . . .
            &lt;/p&gt; 
             . . . 
         &lt;/div&gt;
                            </programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>Convert the text contents of the <quote>spine</quote> critical apparatus into stand-off pointers to the <code>&lt;seg&gt;</code> elements new edition files. Here is a passage from the converted <quote>standoff spine</quote> featuring only the 
                                normalized tokens for each variant passage, and containing pointers to the location of a <code>&lt;seg&gt;</code>
                                element in each edition XML file corresponding with a reading witness:
                            <programlisting language="xml">
            &lt;app xml:id="C10_app7" n="48"&gt;
               &lt;rdgGrp xml:id="C10_app7_rg1"
                       n="['&lt;del&gt;the', 'frame', 'on', 'whic&lt;del&gt;', 'my', 'man', 'completeed,.', '&lt;del&gt;and&lt;del&gt;']"&gt;
                  &lt;rdg wit="#fMS"&gt;
                     &lt;ptr target="https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/fMS_C10.xml#string-range(//tei:surface[@xml:id='ox-ms_abinger_c56-0045']/tei:zone[@type='main']//tei:line[3],15,59)"/&gt;
                  &lt;/rdg&gt;
               &lt;/rdgGrp&gt;
               &lt;rdgGrp xml:id="C10_app7_rg2" n="['the', 'accomplishment', 'of']"&gt;
                  &lt;rdg wit="#f1818"&gt;
                     &lt;ptr target="https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f1818_C10.xml#C10_app7-f1818"/&gt;
                  &lt;/rdg&gt;
                  &lt;rdg wit="#f1823"&gt;
                     &lt;ptr target="https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f1823_C10.xml#C10_app7-f1823"/&gt;
                  &lt;/rdg&gt;
                  &lt;rdg wit="#fThomas"&gt;
                     &lt;ptr target="https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/fThomas_C10.xml#C10_app7-fThomas"/&gt;
                  &lt;/rdg&gt;
                  &lt;rdg wit="#f1831"&gt;
                     &lt;ptr target="https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f1831_C10.xml#C10_app7-f1831"/&gt;
                  &lt;/rdg&gt;
               &lt;/rdgGrp&gt;
            &lt;/app&gt;
                            
                            </programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>Calculate special links and pointers to the original XML files of the Shelley-Godwin Archive's manuscript edition of Frankenstein, adjusting for the resequencing prior to collation.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                </listitem>
                <listitem><para>Publish the XML via a web framework (optimally CETEIcean but <link xlink:href="https://frankensteinvariorum.github.io/viewer/">for now, using Node.js and React</link>). Share the edition text files and XML data from our <link xlink:href="https://github.com/FrankensteinVariorum/fv-data">GitHub repo sharing files at completed stages of our pipeline</link>.
                    <figure xml:id="fvwebview" xreflabel="FV-webView">
                        <title>Web view of a variant passage in the <emphasis role="ital">Frankenstein Variorum</emphasis> reading interface</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata format="png" fileref="Bal2022Besh-FVarWebView.png" width="80%"/>
                            </imageobject>
                        </mediaobject>
                        <caption>
                            <para>A snapshot of the <emphasis role="ital">Frankenstein Variorum</emphasis> web interface showing the 1816 manuscript notebook edition at the moment when Victor Frankenstein looks at the form of his complete Creature, highlighting the variant passage featured in the preceding code blocks. The segmented passages highlight the variants with deepening shades based on Levenshtein distance measurements, divided into 3 ranges (very light for Levenshtein distances of a few characters, more intense for distances above 20).</para>
                        </caption>
                    </figure>
                <footnote>
                    <para>Our production pipeline unfolds in a series of GitHub repos at <link xlink:href="https://github.com/FrankensteinVariorum">https://github.com/FrankensteinVariorum</link>. The repo storing and documenting the post-collation XSLT files, not the focus of discussion for this paper but likely of interest  to our readers is <link xlink:href="https://github.com/FrankensteinVariorum/fv-postCollation">https://github.com/FrankensteinVariorum/fv-postCollation</link>.</para>
                </footnote>
                </para>
                </listitem>
            </orderedlist>
        </para>  
      
    </section>
        
        <section><title>Snags in the Weaving</title>
            <section><title>A Schematron flashlight</title>
                <para>For an unhappy time two years ago, pressed by a deadline to launch a proof-of-concept partial version of the Variorum interface, I hand-corrected the outputs of collation, assisted by Schematron that would help me to identify common problems. The Schematron was like a flashlight guiding me through a brittle process of hand-moving witnesses to apps. The sheer volume of corrections was exhausting, and a short novel like <emphasis role="ital">Frankenstein</emphasis> could seem infinitely long and tortuously slow to read while attempting to make <quote>spine adjustments</quote>. I knew this method was not sufficient for our needs. This Schematron file was merely my first attempt to try to address the problem systematically:
             <programlisting language="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2"&gt;
    &lt;sch:pattern&gt;
        &lt;sch:rule context="app"&gt;
            &lt;sch:report test="not(rdgGrp)" role="error"&gt;Empty app element--missing rdgGrps! That's an error introduced from editing the collation.&lt;/sch:report&gt;
     &lt;sch:report test="contains(descendant::rdg[@wit='fThomas'], '&lt;del')" role="info"&gt;
         Here is a place where the Thomas text contains a deleted passage. Is it completely encompassed in the app?&lt;/sch:report&gt;
            &lt;sch:assert test="count(descendant::rdg/@wit) = count(distinct-values(descendant::rdg/@wit))" role="error"&gt;
                A repeated rdg witness is present! There's an error here introduced by editing the collation.
            &lt;/sch:assert&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
    &lt;sch:pattern&gt;
        &lt;sch:rule context="app[count(rdgGrp) eq 1][count(descendant::rdg) eq 1]"&gt;
            &lt;sch:report test="count(preceding-sibling::app[1]/rdgGrp) eq 1 or count(following-sibling::app[1]/rdgGrp) eq 1 or last()" role="warning"&gt;
                Here is a "singleton" app that may be best merged in with the preceding or following "unison" app as part of a new rdgGrp. 
            &lt;/sch:report&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
    &lt;sch:pattern&gt;
        &lt;sch:let name="delString" value="'&lt;del'"/&gt;
    &lt;sch:rule context="rdg[@wit='fThomas']" role="error"&gt;
        &lt;sch:let name="textTokens" value="tokenize(text(), ' ')"/&gt;
        &lt;sch:let name="delMatch" value="for $t in $textTokens return $t[contains(., $delString)]"/&gt;
        &lt;sch:assert test="count($delMatch) mod 2 eq 0"&gt;
            Unfinished deletion in the Thomas witness. We count &lt;sch:value-of select="count($delMatch)"/&gt; deletion matches. 
            Make sure the Thomas witness deletion is completely encompassed in the app.&lt;/sch:assert&gt;
    &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
    &lt;sch:pattern&gt;
        &lt;sch:rule context="rdgGrp[ancestor::rdgGrp]"&gt;
            &lt;sch:report test="."&gt;A reading group must NOT be nested inside another reading group!&lt;/sch:report&gt;
        &lt;/sch:rule&gt;
    &lt;/sch:pattern&gt;
&lt;/sch:schema&gt;</programlisting>   
                When reviewing and editing collation <quote>spine</quote> files, I would apply this schema to guide my work and stop me from making terrible mistakes in hand-correcting common collation output problems, such as, for example, pasting a <code>&lt;rdgGrp&gt;</code> element inside another <code>&lt;rdgGrp&gt;</code> (permissible and useful in some TEI projects, but an outright mistake in our very simple spine). Eye fatigue is a serious problem in just about every stage of the Gothenburg model, and this Schematron did intervene to prevent clumsy mistakes. More importantly for the long-range work of the project, this simple Schematron file helped me to document and describe repeating patterns of error in the collation, most significantly here the <quote>singleton</quote> <code>&lt;app&gt;</code>, containing only one witness inside, and the incommplete witness that I wanted to include a complete act of deletion.
            </para>
            </section>
            <section><title>XSLT for alignment correction</title>
            <para>Revisiting the collation output in fall 2021 with two student research assistants, we began identifying patterns that XSLT could correct. The output from collateX output would frequently create a problem we called <quote>loner dels</quote>: that is, failing to align text with flattened <code>&lt;del&gt;</code> markup wtih corresponding witnesses, despite the presence of related content with other witnesses. collateX would sometimes place these in an <code>&lt;app&gt;</code> with a single <code>&lt;rdgGrp&gt;</code> by themselves. We succeeded over a few Friday afternoon research team meetings in November to correct this while my students learned about tunneling parameters in XSLT. Our Stylesheet is short but represents a step forward in documentation as well as outright repair of collation alignment:</para>
                <programlisting language="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:cx="http://interedition.eu/collatex/ns/1.0"
    
    exclude-result-prefixes="xs math"
    version="3.0"&gt;
    &lt;!--2021-09-24 ebb with wdjacca and amoebabyte: We are writing XSLT to try to move
    solitary apps reliably into their neighboring app elements representing all witnesses. 
    
    --&gt;
  &lt;xsl:mode on-no-match="shallow-copy"/&gt;
  
&lt;!-- ********************************************************************************************
        LONER DELS: These templates deal with collateX output of app elements 
        containing a solitary MS witness containing a deletion, which we interpret as usually a false start, 
        before a passage.
     *********************************************************************************************
    --&gt;  
    &lt;xsl:template match="app[count(descendant::rdg) = 1][contains(descendant::rdg, '&lt;del')]"&gt;
  
        &lt;xsl:if test="following-sibling::app[1][count(descendant::rdgGrp) = 1 and count(descendant::rdg) gt 1]"&gt;
               &lt;xsl:apply-templates select="following-sibling::app[1]" mode="restructure"&gt;
                  &lt;xsl:with-param as="node()" name="loner" select="descendant::rdg" tunnel="yes" /&gt;
                   &lt;xsl:with-param as="attribute()" name="norm" select="rdgGrp/@n" tunnel="yes"/&gt;
               &lt;/xsl:apply-templates&gt;
               
           &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
    
    
    &lt;xsl:template match="app[preceding-sibling::app[1][count(descendant::rdg) = 1][contains(descendant::rdg, '&lt;del')]]"/&gt;


    &lt;xsl:template match="app" mode="restructure"&gt;
        &lt;xsl:param name="loner" tunnel="yes"/&gt;
        &lt;xsl:param name="norm" tunnel="yes"/&gt;
        &lt;app&gt;
        &lt;xsl:apply-templates select="rdgGrp" mode="restructure"&gt;
                &lt;xsl:with-param  as="node()" name="loner" tunnel="yes" select="$loner"/&gt;
            &lt;/xsl:apply-templates&gt;
            &lt;xsl:variable name="TokenSquished"&gt;
                &lt;xsl:value-of select="$norm ! string()||descendant::rdgGrp[descendant::rdg[@wit=$loner/@wit]]/@n"/&gt;
            &lt;/xsl:variable&gt;
            &lt;xsl:variable name="newToken"&gt;
                &lt;xsl:value-of select="replace($TokenSquished, '\]\[', ', ')"/&gt;
            &lt;/xsl:variable&gt;
           &lt;rdgGrp n="{$newToken}"&gt;
              &lt;rdg wit="{$loner/@wit}"&gt;&lt;xsl:value-of select="$loner/text()"/&gt;
              &lt;xsl:value-of select="descendant::rdg[@wit = $loner/@wit]"/&gt;
              &lt;/rdg&gt;
               
           &lt;/rdgGrp&gt; 
        &lt;/app&gt; 
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="rdgGrp" mode="restructure"&gt;
        &lt;xsl:param name="loner" tunnel="yes"/&gt;

           &lt;xsl:if test="rdg[@wit ne $loner/@wit]"&gt;
            &lt;xsl:copy-of select="current()" /&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</programlisting>
    <para>Next my little team and I began to tackle the noxious problem of <quote>empty tokens</quote>, that is, spurious <code>&lt;rdgGrp&gt;</code> elements that would form around a single witness, the SGA manuscript witness, with an empty normalized token formed on a normalized <code>&lt;lb/&gt;</code> element. In their most benign and frequently occurring form, they would appear a separate isolated <code>&lt;app&gt;</code> elements in between two <quote>unison apps</quote> (that is, interrupting a passage in which all witnesses should align in unison. Here is an example of the pattern. Those reading vigilantly will note that the expected octothorpe or sharp <code>#</code> characters indicating that this is a pointer to a defined <code>@xml:id</code> do not appear in the <code>@wit</code> attribute values in this example. These are simply lacking at their point of output from collateX, before it is reprocessed in the post-production pipeline as a TEI document. 
    <programlisting language="xml">
     &lt;app&gt;
		&lt;rdgGrp n="['as', 'i', 'did', 'not', 'appear', 'to', 'know']"&gt;
			&lt;rdg wit="f1818"&gt;as I did not appear to know &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;as I did not appear to know &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;as I did not appear to know &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;as I did not appear to know &lt;/rdg&gt;
			&lt;rdg wit="fMS"&gt;as I did not appear to know &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
	&lt;app&gt;
		&lt;rdgGrp n="['']"&gt;
			&lt;rdg wit="fMS"&gt;&lt;lb n=&quot;c57-0119__main__14&quot;/&gt; &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
	&lt;app&gt;
		&lt;rdgGrp n="['the']"&gt;
			&lt;rdg wit="f1818"&gt;the &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;the &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;the &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;the &lt;/rdg&gt;
			&lt;rdg wit="fMS"&gt;the &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;</programlisting>
   The <quote>empty token</quote> problem is evident here in the normalized form a lb element with all its attributes, being read properly as an empty token (not even a space), but somehow asserting its presence to interrupt a unison passage. At this point, there should be only one <code>&lt;app&gt;</code> element that should appear like this:
        <programlisting language="xml">
            &lt;app&gt;
		&lt;rdgGrp n="['as', 'i', 'did', 'not', 'appear', 'to', 'know', 'the']"&gt;
			&lt;rdg wit="f1818"&gt;as I did not appear to know the &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;as I did not appear to know the &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;as I did not appear to know the &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;as I did not appear to know the &lt;/rdg&gt;
			&lt;rdg wit="fMS"&gt;as I did not appear to know the &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
        </programlisting>
       There is a more complex form of this pernicious problem with collating around normalized markup, and that is when the token asserts itself to generate a delta, a separate <code>&lt;rdgGrp&gt;</code> within an app, as happens here:
        <programlisting language="xml">
    &lt;app&gt;
		&lt;rdgGrp n="['departed.', 'besides,', 'they']"&gt;
			&lt;rdg wit="f1818"&gt;departed. Besides, they &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;departed. Besides, they &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;departed. Besides, they &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;departed. Besides, they &lt;/rdg&gt;
			&lt;rdg wit="fMS"&gt;departed. Besides, they &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
	&lt;app&gt;
		&lt;rdgGrp n="['observed']"&gt;
			&lt;rdg wit="f1818"&gt;observed &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;observed &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;observed &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;observed &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
		&lt;rdgGrp n="['observed,', '']"&gt;
			&lt;rdg wit="fMS"&gt;observed, &lt;lb n=&quot;c57-0119__main__11&quot;/&gt; &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
	&lt;app&gt;
		&lt;rdgGrp n="['that', 'it', 'appeared']"&gt;
			&lt;rdg wit="f1818"&gt;that it appeared &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;that it appeared &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;that it appeared &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;that it appeared &lt;/rdg&gt;
			&lt;rdg wit="fMS"&gt;that it appeared &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
        </programlisting>
    The capacity of the empty token to create a <quote>snag</quote> in the collation weave is evident here, generating a false divergence. These <code>&lt;app&gt;</code>s should all be consolidated into one element wth just one unison <code>&lt;rdgGrp&gt;</code>. My research team and I took notes on the various forms this empty token phenomenon could take and drafted notes, still on my office whiteboard, for how we could handle them with XSLT.
    </para>
            <figure xml:id="fvwhiteboard" xreflabel="FV-whiteboard">
                <title>Frankenstein collation notes on my office whiteboard</title>
                <mediaobject>
                    <imageobject>
                        <imagedata format="jpg" fileref="Bal2022Besh-FVWhiteBoard.jpg" width="80%"/>
                    </imageobject>
                </mediaobject>
                <caption>
                    <para>My student Jacqueline Chan, Penn State Behrend May 2022 Digital Media, Arts, and Technology graduate, carefully drafted these notes on the <quote>empty token</quote> collation problem and our efforts to solve it on my office whiteboard during a meeting with my student research assistants as we inspected collation output code together.</para>
                </caption>
            </figure>

            </section>
           
     <section><title>The <quote>smashed-tokens</quote> problem</title>
           <para>We discovered another particularly pernicious problem with tokenizing and normalizing markup via our Python process to collateX. This problem is one of occasional <quote>smashed-tokens</quote>, that is two tokens losing their space separator and becoming one token. Here is a very short passage of XML from the Shelley-Godwin Archive's encoding:
               <programlisting language="xml">
                 . . . the spot&lt;add eID="c57-0117__main__d3e21951"/&gt; &amp; endeavoured . . .   
               </programlisting>
     In this passage, we will be normalizing to ignore the <code>&lt;add&gt;</code> element. Notice the spaces separating the element tag from the ampersand. Now, here is how collateX interprets the passage in its collation alignment:
               <programlisting language="xml">
    &lt;app&gt;
		&lt;rdgGrp n="['spot,', 'and', 'endeavoured,']"&gt;
			&lt;rdg wit="f1818"&gt;spot, and endeavoured, &lt;/rdg&gt;
			&lt;rdg wit="f1823"&gt;spot, and endeavoured, &lt;/rdg&gt;
			&lt;rdg wit="fThomas"&gt;spot, and endeavoured, &lt;/rdg&gt;
			&lt;rdg wit="f1831"&gt;spot, and endeavoured, &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
		&lt;rdgGrp n="['spotand', 'endeavoured']"&gt;
			&lt;rdg wit="fMS"&gt;spot&amp; endeavoured &lt;/rdg&gt;
		&lt;/rdgGrp&gt;
	&lt;/app&gt;
               </programlisting>
               
               Somewhere in the normalizing process, the two completely separate tokens <quote>spot</quote> and <quote>and</quote> were spliced together into one token. We are not certain whether this problem is more with Python's tokenization or with collateX's alignment of normalized empty strings representing markup irrelevant to the collation. It's as if the normalized markup refuses quite to disappear, haunting the collation machinery with a ghostly persistent trace. We are also not certain at the date of this writing whether choosing a different alignment algorithm in collateX might resolve the problem, but I think not, since error seems to be in interpreting spaces following normalization. That is, I believe the problems could be in the Python script that handles the normalization.</para>
         
         <para>At the date of this writing, we have not completed these XSLT post-processing tasks, in part because we all became busy wih senior projects (for them, completing their projects and for me, assisting with them). I have also paused a moment before continuing down this path because the more patterns we discovered to correct, the more I wanted to try another XSLT approach. If our normalization and alignment were so disjointed to require so much XSLT post-processing, what if XSLT might simply be better at the task of normalizing markup and tokenizing and aligning around it? That is, would it be less brittle to use XSLT for all of our processing, including the collation itself? </para>
        </section>
      
       

    </section>
        <section><title>XSLT for the win?</title>
            <para>At the August 2021 Balisage conference, Joel Kalvesmaki introduced tan diff and tan collate, 
                As I listened to the paper, I was struck by how simple Kalvesmaki made the process of string comparison seem in his explanation of tan:diff():  <blockquote><para>tan:diff() . . . extracts a series of progressively smaller samples from the shorter of the two texts and looks for a match in the longer one on the basis of fn:contains(). When a match is found, the results are separated by fn:substring-before() and fn:substring-after()<footnote><para>Kalvesmaki, Joel. <quote>String Comparison in XSLT with tan:diff().</quote> Presented at Balisage: The Markup Conference 2021, Washington, DC, August 2 - 6, 2021. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference 2021. Balisage Series on Markup Technologies</emphasis>, vol. 26 (2021). <link xlink:href="https://doi.org/10.4242/BalisageVol26.Kalvesmaki01">https://doi.org/10.4242/BalisageVol26.Kalvesmaki01</link>.</para></footnote></para></blockquote>
The simple use of XPath functions described here made the alignment process seem more familiar and accessible, amenable to the kinds of modifications I regularly make with my own XSLT. I wondered whether starting with attempts to match longer samples and moving to match shorter ones might generate fewer aligned clusters and reduce the spurious particulation I had been seeing in my Python-assisted process with collateX. So I have lately begun experimenting with tan:diff and tan:collate().
            </para>
           <para>At the time of this writing, I have begun testing a collation unit from the <emphasis role="ital">Frankenstein Variorum</emphasis>, the same featured above that produced the <quote>smashed tokens</quote> problem featured in the previous section. Currently I am applying the software following Kalvesmaki's detailed comments within his sample Diff XSLT files guiding the user to generate TAN Diff's native XML and HTML output. The XML output is like, but yet unlike the TEI critical apparatus structure we have been using in the <emphasis role="ital">Frankenstein Variorum</emphasis> project. The markup is simply organized in <code>&lt;c&gt;</code> when all witnesses share a normalized string, and <code>&lt;u&gt;</code> when they are variant from each other. There is nothing like the <code>&lt;app&gt;</code> element to bundle together related groups. But this is the realm of XSLT and the developers encourage their users to adapt the code to their needs. I have not yet definitively located where to apply the <code>&lt;app&gt;</code> element I require in the XSLT file housing tan:collate()'s functions, but I will almost certainly do so before the conference.</para>
            <para>Most importantly, I have been applying and updating my 25 normalizing replacement patterns via XSLT and find this much more legible than my handling of the same in my Python script (which sometimes contained duplicate passages). XSLT, by nature of being written in XML is XPathable, and with a large quantity of replacement sequences, I am able to check and sequence the process carefully in a way that is easier for me to document legibly.
            <programlisting language="xml">
                &lt;!-- Should punctuation be ignored? --&gt;
    &lt;xsl:param name="tan:ignore-punctuation-differences" as="xs:boolean" select="false()"/&gt;
    
    &lt;xsl:param name="additional-batch-replacements" as="element()*"&gt;
        &lt;!--ebb: normalizations to batch process for collation. NOTE: We want to do these to preserve some markup \\
            in the output for post-processing to reconstruct the edition files. 
            Remember, these will be processed in order, so watch out for conflicts. --&gt;
        &lt;replace pattern="(&lt;.+?&gt;\s*)&amp;gt;" replacement="$1" message="normalizing away extra right angle brackets"/&gt;
         &lt;replace pattern="&amp;amp;" replacement="and" message="ampersand batch replacement"/&gt;
        &lt;replace pattern="&lt;/?xml&gt;" replacement="" message="xml tag replacement"/&gt;
        &lt;replace pattern="(&lt;p)\s+.+?(/&gt;)" replacement="$1$2" message="p-tag batch replacement"/&gt;
        &lt;replace pattern="(&lt;)(metamark).*?(&gt;).+?\1/\2\3" replacement="" message="metamark batch replacement"/&gt;&lt;!--ebb: metamark contains a text node, and we don't want its contents processed in the collation, so this captures the entire element. --&gt;
        &lt;replace pattern="(&lt;/?)m(del).*?(&gt;)" replacement="$1$2$3" message="mdel-SGA batch replacement"/&gt;  &lt;!--ebb: mdel contains a text node, so this catches both start and end tag.
        We want mdel to be processed as &lt;del&gt;...&lt;/del&gt;--&gt;
        &lt;replace pattern="&lt;/?damage.*?&gt;" replacement="" message="damage-SGA batch replacement"/&gt; &lt;!--ebb: damage contains a text node, so this catches both start and end tag. --&gt;
        &lt;replace pattern="&lt;/?unclear.*?&gt;" replacement="" message="unclear-SGA batch replacement"/&gt; &lt;!--ebb: unclear contains a text node, so this catches both start and end tag. --&gt;
        &lt;replace pattern="&lt;/?retrace.*?&gt;" replacement="" message="retrace-SGA batch replacement"/&gt; &lt;!--ebb: retrace contains a text node, so this catches both start and end tag. --&gt;
        &lt;replace pattern="&lt;/?shi.*?&gt;" replacement="" message="shi-SGA batch replacement"/&gt; &lt;!--ebb: shi (superscript/subscript) contains a text node, so this catches both start and end tag. --&gt;
        &lt;replace pattern="(&lt;del)\s+.+?(/&gt;)" replacement="$1$2" message="del-tag batch replacement"/&gt;
        &lt;replace pattern="&lt;hi.+?/&gt;" replacement="" message="hi batch replacement"/&gt;
        &lt;replace pattern="&lt;pb.+?/&gt;" replacement="" message="pb batch replacement"/&gt;
        &lt;replace pattern="&lt;add.+?&gt;" replacement="" message="add batch replacement"/&gt;
        &lt;replace pattern="&lt;w.+?/&gt;" replacement="" message="w-SGA batch replacement"/&gt;
        &lt;replace pattern="(&lt;del)Span.+?spanTo=&quot;#(.+?)&quot;.*?(/&gt;)(.+?)&lt;anchor.+?xml:id=&quot;\2&quot;.*?&gt;" replacement="$1$3$4$1$3" message="delSpan-to-anchor-SGA batch replacement"/
       &lt;replace pattern="&lt;anchor.+?/&gt;" replacement="" message="anchor-SGA batch replacement"/&gt;  
        &lt;replace pattern="&lt;milestone.+?unit=&quot;tei:p&quot;.+?/&gt;" replacement="&lt;p/&gt; &lt;p/&gt;" message="milestone-paragraph-SGA batch replacement"/&gt;  
        &lt;replace pattern="&lt;milestone.+?/&gt;" replacement="" message="milestone non-p batch replacement"/&gt;  
        &lt;replace pattern="&lt;lb.+?/&gt;" replacement="" message="lb batch replacement"/&gt;  
        &lt;replace pattern="&lt;surface.+?/&gt;" replacement="" message="surface-SGA batch replacement"/&gt; 
        &lt;replace pattern="&lt;zone.+?/&gt;" replacement="" message="zone-SGA batch replacement"/&gt; 
        &lt;replace pattern="&lt;mod.+?/&gt;" replacement="" message="mod-SGA batch replacement"/&gt; 
        &lt;replace pattern="&lt;restore.+?/&gt;" replacement="" message="restore-SGA batch replacement"/&gt; 
        &lt;replace pattern="&lt;graphic.+?/&gt;" replacement="" message="graphic-SGA batch replacement"/&gt; 
        &lt;replace pattern="&lt;head.+?/&gt;" replacement="" message="head batch replacement"/&gt; 
 
            </programlisting>
                
              The documentation-centered nature of the TAN stylesheets makes the XSLT function to document decisions and makes it easy to amend the process and resequence it. Contrast this with the brittle complexity of my Python normalization function and its dependencies:
                
                <programlisting language="python">
regexWhitespace = re.compile(r'\s+')
regexNonWhitespace = re.compile(r'\S+')
regexEmptyTag = re.compile(r'/&gt;$')
regexBlankLine = re.compile(r'\n{2,}')
regexLeadingBlankLine = re.compile(r'^\n')
regexPageBreak = re.compile(r'&lt;pb.+?/&gt;')
RE_MARKUP = re.compile(r'&lt;.+?&gt;')
RE_PARA = re.compile(r'&lt;p\s[^&lt;]+?/&gt;')
RE_INCLUDE = re.compile(r'&lt;include[^&lt;]*/&gt;')
RE_MILESTONE = re.compile(r'&lt;milestone[^&lt;]*/&gt;')
RE_HEAD = re.compile(r'&lt;head[^&lt;]*/&gt;')
RE_AB = re.compile(r'&lt;ab[^&lt;]*/&gt;')
# 2018-10-1 ebb: ampersands are apparently not treated in python regex as entities any more than angle brackets.
# RE_AMP_NSB = re.compile(r'\S&amp;\s')
# RE_AMP_NSE = re.compile(r'\s&amp;\S')
# RE_AMP_SQUISH = re.compile(r'\S&amp;\S')
# RE_AMP = re.compile(r'\s&amp;\s')
RE_AMP = re.compile(r'&amp;')
# RE_MULTICAPS = re.compile(r'(?&lt;=\W|\s|\&gt;)[A-Z][A-Z]+[A-Z]*\s')
# RE_INNERCAPS = re.compile(r'(?&lt;=hi\d"/&gt;)[A-Z]+[A-Z]+[A-Z]+[A-Z]*')
# TITLE_MultiCaps = match(RE_MULTICAPS).lower()
RE_DELSTART = re.compile(r'&lt;del[^&lt;]*&gt;')
RE_ADDSTART = re.compile(r'&lt;add[^&lt;]*&gt;')
RE_MDEL = re.compile(r'&lt;mdel[^&lt;]*&gt;.+?&lt;/mdel&gt;')
RE_SHI = re.compile(r'&lt;shi[^&lt;]*&gt;.+?&lt;/shi&gt;')
RE_METAMARK = re.compile(r'&lt;metamark[^&lt;]*&gt;.+?&lt;/metamark&gt;')
RE_HI = re.compile(r'&lt;hi\s[^&lt;]*/&gt;')
RE_PB = re.compile(r'&lt;pb[^&lt;]*/&gt;')
RE_LB = re.compile(r'&lt;lb.*?/&gt;')
# 2021-09-06: ebb and djb: On &lt;lb&gt; collation troubles: LOOK FOR DOT MATCHES ALL FLAG
# b/c this is likely spanning multiple lines, and getting split by the tokenizing algorithm.
# 2021-09-10: ebb with mb and jc: trying .*? and DOTALL flag
RE_LG = re.compile(r'&lt;lg[^&lt;]*/&gt;')
RE_L = re.compile(r'&lt;l\s[^&lt;]*/&gt;')
RE_CIT = re.compile(r'&lt;cit\s[^&lt;]*/&gt;')
RE_QUOTE = re.compile(r'&lt;quote\s[^&lt;]*/&gt;')
RE_OPENQT = re.compile(r'“')
RE_CLOSEQT = re.compile(r'”')
RE_GAP = re.compile(r'&lt;gap\s[^&lt;]*/&gt;')
# &lt;milestone unit="tei:p"/&gt;
RE_sgaP = re.compile(r'&lt;milestone\sunit="tei:p"[^&lt;]*/&gt;')

. . .

def normalize(inputText):
# 2018-09-23 ebb THIS WORKS, SOMETIMES, BUT NOT EVERWHERE: RE_MULTICAPS.sub(format(re.findall(RE_MULTICAPS, inputText, flags=0)).title(), \
# RE_INNERCAPS.sub(format(re.findall(RE_INNERCAPS, inputText, flags=0)).lower(), \
    return RE_MILESTONE.sub('', \
        RE_INCLUDE.sub('', \
        RE_AB.sub('', \
        RE_HEAD.sub('', \
        RE_AMP.sub('and', \
        RE_MDEL.sub('', \
        RE_SHI.sub('', \
        RE_HI.sub('', \
        RE_LB.sub('', \
        RE_PB.sub('', \
        RE_PARA.sub('&lt;p/&gt;', \
        RE_sgaP.sub('&lt;p/&gt;', \
        RE_LG.sub('&lt;lg/&gt;', \
        RE_L.sub('&lt;l/&gt;', \
        RE_CIT.sub('', \
        RE_QUOTE.sub('', \
        RE_OPENQT.sub('"', \
        RE_CLOSEQT.sub('"', \
        RE_GAP.sub('', \
        RE_DELSTART.sub('&lt;del&gt;', \
        RE_ADDSTART.sub('&lt;add&gt;', \
        RE_METAMARK.sub('', inputText)))))))))))))))))))))).lower()  
                </programlisting>            
 I came to realize that in the more writerly environment of the XSLT stylesheets for TAN Diff, It is easier to review the code, which would be helpful to me setitng it down and returning to it after some months or years. 
            </para>
            <para>More to the point of this experiment with a new alignment method, does it succeed in reducing the tokenization and noramlization alignments discussed in the previous section? So far, yes, often with identical correct alignments and usually with longer matches. For example, on the passage that illustrated the <quote>smashed tokens</quote> problem, here is tan collate's output: 
            <programlisting language="xml">
                &lt;u&gt;
         &lt;txt&gt;spot,&lt;/txt&gt;
         &lt;wit ref="2-1818_fullFlat_C27" pos="1423"/&gt;
         &lt;wit ref="4-Thomas_fullFlat_C27" pos="1423"/&gt;
         &lt;wit ref="3-1823_fullFlat_C27" pos="1421"/&gt;
         &lt;wit ref="5-1831_fullFlat_C27" pos="1422"/&gt;
      &lt;/u&gt;
      &lt;u&gt;
         &lt;txt&gt;spot&lt;/txt&gt;
         &lt;wit ref="1-msColl_C27" pos="317"/&gt;
      &lt;/u&gt;
      &lt;c&gt;
         &lt;txt&gt; and &lt;/txt&gt;
         &lt;wit ref="2-1818_fullFlat_C27" pos="1428"/&gt;
         &lt;wit ref="4-Thomas_fullFlat_C27" pos="1428"/&gt;
         &lt;wit ref="3-1823_fullFlat_C27" pos="1426"/&gt;
         &lt;wit ref="5-1831_fullFlat_C27" pos="1427"/&gt;
         &lt;wit ref="1-msColl_C27" pos="321"/&gt;
      &lt;/c&gt;
      &lt;u&gt;
         &lt;txt&gt;endeavoured,&lt;/txt&gt;
         &lt;wit ref="2-1818_fullFlat_C27" pos="1433"/&gt;
         &lt;wit ref="4-Thomas_fullFlat_C27" pos="1433"/&gt;
         &lt;wit ref="3-1823_fullFlat_C27" pos="1431"/&gt;
         &lt;wit ref="5-1831_fullFlat_C27" pos="1432"/&gt;
      &lt;/u&gt;
      &lt;u&gt;
         &lt;txt&gt;endeavoured &lt;/txt&gt;
         &lt;wit ref="1-msColl_C27" pos="326"/&gt;
      &lt;/u&gt;     
            </programlisting>
                
I have found no problems with empty tokens created from markup, and overall the number of aligned groups is much smaller. Here is a summary of total aligned reading groups and unison aligned reading groups for the same collation unit as processed by Python-mediated CollateX vs. Tan Diff XSLT:

                <table xml:id="mul-table1" frame="box">
                    <caption>
                        <para>Alignments generated by CollateX vs. Tan Diff</para>
                    </caption>
             <!--       <colgroup>
                        <col align="right" valign="top"/>
                        <col valign="top"/>
                        <col align="center" valign="top"/>
                    </colgroup> -->
                    <thead>
                        <tr valign="top">
                            <th>Alignment</th>
                            <th>CollateX</th>
                            <th>Tan Diff/Collate</th>
       
                        </tr>
                    </thead>
                    <tbody>
                       <tr>
                           <th>Unison Alignments (all witnesses the same)</th>
                           <td>1198</td>
                           <td>515</td>
                       </tr>
                        <tr>
                            <th>All Alignments (unison and divergent)</th>
                            <td>2315</td>
                            <td>1932</td>
                        </tr>
                    </tbody>
                </table>
                In general, the alignments were longer in tan diff (as expected), and the tokenization and normalization outcomes are much more reliable. At the time of this writing, it seems to make sound sense to take a moment and adapt tan collate to the pipeline of the <emphasis role="ital">Frankenstein Variorum</emphasis> project, since it appears even <quote>out of the box</quote> to produce fewer alignment problems. By the time of the Balisage conference, I will have completed a more thorough analysis of tan diff's adaptability for this project and its potential to reduce the complexity of our workflow, reviewing it with more complicated passages of more divergent witnesses. XSLT and XPath functions appear to be a robust way of handling the complex algorithms of collation, and a wise application in nearly all stages of the Gothenburg model. 
            </para>    
        </section>
</article>
